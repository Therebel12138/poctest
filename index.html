<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JSBridge æ¥å£æ£€æµ‹å·¥å…·</title>
<style>
  body {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: #f5f5f5;
    line-height: 1.6;
  }
  .header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    text-align: center;
  }
  .section {
    background: white;
    border: 1px solid #ddd;
    margin: 15px 0;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .section-header {
    background: #f8f9fa;
    padding: 15px;
    border-bottom: 1px solid #ddd;
    font-weight: bold;
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .section-content {
    padding: 15px;
    max-height: 400px;
    overflow-y: auto;
  }
  .collapsed .section-content {
    display: none;
  }
  .interface-item {
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 5px;
    margin: 10px 0;
    padding: 15px;
  }
  .interface-name {
    font-weight: bold;
    color: #2c3e50;
    font-size: 16px;
    margin-bottom: 10px;
  }
  .method-list {
    margin-left: 20px;
  }
  .method-item {
    background: white;
    border-left: 3px solid #3498db;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 3px;
  }
  .method-name {
    font-weight: bold;
    color: #e74c3c;
  }
  .method-type {
    color: #27ae60;
    font-size: 12px;
    background: #ecf0f1;
    padding: 2px 6px;
    border-radius: 3px;
    margin-left: 10px;
  }
  .test-btn {
    background: #3498db;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    margin-left: 10px;
  }
  .test-btn:hover {
    background: #2980b9;
  }
  .controls {
    text-align: center;
    margin: 20px 0;
  }
  .control-btn {
    background: #2ecc71;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 5px;
    cursor: pointer;
    margin: 5px;
    font-size: 14px;
  }
  .control-btn:hover {
    background: #27ae60;
  }
  .stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin: 20px 0;
  }
  .stat-card {
    background: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    border: 1px solid #ddd;
  }
  .stat-number {
    font-size: 2em;
    font-weight: bold;
    color: #3498db;
  }
  .stat-label {
    color: #7f8c8d;
    margin-top: 5px;
  }
  .console-output {
    background: #2c3e50;
    color: #ecf0f1;
    padding: 15px;
    border-radius: 5px;
    font-family: monospace;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    margin: 15px 0;
  }
  .search-box {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    margin-bottom: 15px;
    font-size: 14px;
  }
  .highlight {
    background-color: yellow;
    padding: 2px 4px;
    border-radius: 2px;
  }
  .toggle-arrow {
    transition: transform 0.3s ease;
  }
  .collapsed .toggle-arrow {
    transform: rotate(-90deg);
  }
  .loading {
    text-align: center;
    padding: 20px;
    color: #7f8c8d;
  }
  .warning {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    color: #856404;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
  }
  .export-btn {
    background: #e67e22;
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 3px;
    cursor: pointer;
    margin-left: 10px;
  }
  .copy-btn {
    background: #9b59b6;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    margin-left: 5px;
  }
</style>
</head>
<body>

<div class="header">
  <h1>ğŸ” JSBridge æ¥å£æ£€æµ‹å·¥å…·</h1>
  <p>è‡ªåŠ¨æ£€æµ‹å¹¶æ˜¾ç¤º Android WebView ä¸­æ³¨å…¥çš„æ‰€æœ‰ JavaScript æ¥å£</p>
</div>

<div class="warning">
  âš ï¸ <strong>å®‰å…¨æé†’:</strong> æ­¤å·¥å…·ç”¨äºå®‰å…¨æµ‹è¯•å’Œè°ƒè¯•ç›®çš„ã€‚å‘ç°çš„æ¥å£å¯èƒ½åŒ…å«æ•æ„ŸåŠŸèƒ½ï¼Œè¯·è°¨æ…æµ‹è¯•ã€‚
</div>

<div class="controls">
  <button class="control-btn" onclick="startDetection()">ğŸ” å¼€å§‹æ£€æµ‹</button>
  <button class="control-btn" onclick="refreshDetection()">ğŸ”„ åˆ·æ–°æ£€æµ‹</button>
  <button class="control-btn" onclick="clearConsole()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
  <button class="export-btn" onclick="exportResults()">ğŸ“¤ å¯¼å‡ºç»“æœ</button>
  <button class="control-btn" onclick="toggleAll()">ğŸ“ æŠ˜å /å±•å¼€å…¨éƒ¨</button>
</div>

<div class="stats" id="stats">
  <div class="stat-card">
    <div class="stat-number" id="total-interfaces">0</div>
    <div class="stat-label">å‘ç°çš„æ¥å£</div>
  </div>
  <div class="stat-card">
    <div class="stat-number" id="total-methods">0</div>
    <div class="stat-label">å¯ç”¨æ–¹æ³•</div>
  </div>
  <div class="stat-card">
    <div class="stat-number" id="testable-methods">0</div>
    <div class="stat-label">å¯æµ‹è¯•æ–¹æ³•</div>
  </div>
  <div class="stat-card">
    <div class="stat-number" id="detection-time">0ms</div>
    <div class="stat-label">æ£€æµ‹è€—æ—¶</div>
  </div>
</div>

<input type="text" class="search-box" id="searchBox" placeholder="ğŸ” æœç´¢æ¥å£æˆ–æ–¹æ³•å..." onkeyup="filterInterfaces()">

<div class="console-output" id="console">
ç­‰å¾…å¼€å§‹æ£€æµ‹...\nç‚¹å‡»"å¼€å§‹æ£€æµ‹"æŒ‰é’®æ¥æ‰«æå¯ç”¨çš„ JSBridge æ¥å£
</div>

<div id="interfaces-container">
  <!-- åŠ¨æ€ç”Ÿæˆçš„æ¥å£åˆ—è¡¨å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
</div>

<script>
let detectedInterfaces = {};
let consoleLog = [];
let allCollapsed = false;

// æ—¥å¿—è¾“å‡ºå‡½æ•°
function log(message, type = 'info') {
  const timestamp = new Date().toLocaleTimeString();
  const logEntry = `[${timestamp}] ${message}`;
  consoleLog.push(logEntry);
  
  const console = document.getElementById('console');
  console.textContent = consoleLog.join('\n');
  console.scrollTop = console.scrollHeight;
}

// æ¸…ç©ºæ§åˆ¶å°
function clearConsole() {
  consoleLog = [];
  document.getElementById('console').textContent = 'æ§åˆ¶å°å·²æ¸…ç©º';
}

// æ£€æµ‹ JSBridge æ¥å£
function startDetection() {
  const startTime = performance.now();
  log('ğŸ” å¼€å§‹æ£€æµ‹ JSBridge æ¥å£...');
  
  detectedInterfaces = {};
  let totalMethods = 0;
  let testableMethods = 0;
  
  try {
    // æ£€æµ‹ window å¯¹è±¡ä¸Šçš„è‡ªå®šä¹‰å±æ€§
    const windowProps = Object.getOwnPropertyNames(window);
    log(`ğŸ“‹ æ£€æµ‹åˆ° window å¯¹è±¡ä¸Šæœ‰ ${windowProps.length} ä¸ªå±æ€§`);
    
    // å¸¸è§çš„ JSBridge æ¥å£åç§°æ¨¡å¼
    const bridgePatterns = [
      /^Android/i,
      /^app/i,
      /^bridge/i,
      /^native/i,
      /^webkit/i,
      /^js/i,
      /^mobile/i,
      /^device/i,
      /^api/i,
      /^sdk/i,
      /^plugin/i,
      /^client/i,
      /^host/i,
      /^container/i
    ];
    
    // æ£€æŸ¥æ¯ä¸ªå±æ€§
    windowProps.forEach(prop => {
      try {
        const obj = window[prop];
        
        // è·³è¿‡åŸç”Ÿ DOM å’Œæµè§ˆå™¨ API
        if (isNativeProperty(prop)) {
          return;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¯¹è±¡ä¸”å¯èƒ½æ˜¯ JSBridge
        if (obj && typeof obj === 'object' && obj !== window) {
          const isBridge = bridgePatterns.some(pattern => pattern.test(prop)) || 
                          hasJSBridgeMethods(obj);
          
          if (isBridge) {
            log(`ğŸ¯ å‘ç°ç–‘ä¼¼ JSBridge æ¥å£: ${prop}`);
            detectedInterfaces[prop] = analyzeInterface(obj, prop);
            totalMethods += Object.keys(detectedInterfaces[prop].methods).length;
            testableMethods += detectedInterfaces[prop].testableMethods;
          }
        }
        
        // æ£€æŸ¥å‡½æ•°ç±»å‹çš„æ¥å£
        if (typeof obj === 'function' && !isNativeFunction(obj)) {
          const isBridge = bridgePatterns.some(pattern => pattern.test(prop));
          if (isBridge) {
            log(`ğŸ”§ å‘ç°å‡½æ•°ç±»å‹æ¥å£: ${prop}`);
            detectedInterfaces[prop] = {
              type: 'function',
              methods: { [prop]: { type: 'function', testable: true } },
              testableMethods: 1
            };
            totalMethods += 1;
            testableMethods += 1;
          }
        }
        
      } catch (error) {
        // å¿½ç•¥è®¿é—®é”™è¯¯çš„å±æ€§
      }
    });
    
    // ç‰¹æ®Šæ£€æµ‹ï¼šæŸ¥æ‰¾éšè—çš„æ¥å£
    detectHiddenInterfaces();
    
    const endTime = performance.now();
    const detectionTime = Math.round(endTime - startTime);
    
    log(`âœ… æ£€æµ‹å®Œæˆï¼å‘ç° ${Object.keys(detectedInterfaces).length} ä¸ªæ¥å£ï¼Œ${totalMethods} ä¸ªæ–¹æ³•`);
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    updateStats(Object.keys(detectedInterfaces).length, totalMethods, testableMethods, detectionTime);
    
    // æ¸²æŸ“æ¥å£åˆ—è¡¨
    renderInterfaces();
    
  } catch (error) {
    log(`âŒ æ£€æµ‹è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ${error.message}`);
  }
}

// åˆ¤æ–­æ˜¯å¦ä¸ºåŸç”Ÿå±æ€§
function isNativeProperty(prop) {
  const nativeProps = [
    'window', 'document', 'navigator', 'location', 'history', 'screen',
    'console', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
    'XMLHttpRequest', 'fetch', 'Promise', 'Array', 'Object', 'String',
    'Number', 'Boolean', 'Date', 'RegExp', 'Error', 'JSON', 'Math',
    'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'encodeURIComponent',
    'decodeURIComponent', 'alert', 'confirm', 'prompt', 'open', 'close',
    'localStorage', 'sessionStorage', 'indexedDB', 'crypto', 'performance'
  ];
  
  return nativeProps.includes(prop) || 
         prop.startsWith('webkit') && !prop.includes('Bridge') ||
         prop.startsWith('moz') || 
         prop.startsWith('ms') || 
         prop.startsWith('o') && prop.length < 4;
}

// åˆ¤æ–­æ˜¯å¦ä¸ºåŸç”Ÿå‡½æ•°
function isNativeFunction(func) {
  return func.toString().includes('[native code]');
}

// æ£€æŸ¥å¯¹è±¡æ˜¯å¦åŒ…å« JSBridge æ–¹æ³•
function hasJSBridgeMethods(obj) {
  try {
    const methods = Object.getOwnPropertyNames(obj);
    const bridgeMethods = methods.filter(method => 
      typeof obj[method] === 'function' && 
      !isNativeFunction(obj[method])
    );
    return bridgeMethods.length > 0;
  } catch (error) {
    return false;
  }
}

// åˆ†ææ¥å£è¯¦æƒ…
function analyzeInterface(obj, interfaceName) {
  const analysis = {
    type: 'object',
    methods: {},
    properties: {},
    testableMethods: 0
  };
  
  try {
    const props = Object.getOwnPropertyNames(obj);
    
    props.forEach(prop => {
      try {
        const value = obj[prop];
        
        if (typeof value === 'function') {
          const funcStr = value.toString();
          const isTestable = !isNativeFunction(value);
          
          analysis.methods[prop] = {
            type: 'function',
            testable: isTestable,
            parameters: extractParameters(funcStr),
            source: funcStr.length > 200 ? funcStr.substring(0, 200) + '...' : funcStr
          };
          
          if (isTestable) {
            analysis.testableMethods++;
          }
          
        } else {
          analysis.properties[prop] = {
            type: typeof value,
            value: typeof value === 'object' ? '[Object]' : String(value)
          };
        }
      } catch (error) {
        analysis.properties[prop] = {
          type: 'unknown',
          value: '[è®¿é—®å—é™]',
          error: error.message
        };
      }
    });
    
  } catch (error) {
    log(`âš ï¸ åˆ†ææ¥å£ ${interfaceName} æ—¶å‡ºé”™: ${error.message}`);
  }
  
  return analysis;
}

// æå–å‡½æ•°å‚æ•°
function extractParameters(funcStr) {
  try {
    const match = funcStr.match(/\(([^)]*)\)/);
    if (match && match[1]) {
      return match[1].split(',').map(param => param.trim()).filter(p => p);
    }
  } catch (error) {
    // å¿½ç•¥è§£æé”™è¯¯
  }
  return [];
}

// æ£€æµ‹éšè—çš„æ¥å£
function detectHiddenInterfaces() {
  log('ğŸ” æ£€æµ‹éšè—æ¥å£...');
  
  // å¸¸è§çš„éšè—æ¥å£åç§°
  const hiddenNames = [
    'AndroidInterface', 'NativeInterface', 'AppInterface', 'MobileInterface',
    'JSBridge', 'WebViewBridge', 'HybridBridge', 'ClientBridge',
    'nativeAPI', 'appAPI', 'mobileAPI', 'deviceAPI',
    'webkit', 'chrome', 'safari', 'firefox'
  ];
  
  hiddenNames.forEach(name => {
    try {
      if (window[name] && !detectedInterfaces[name]) {
        log(`ğŸ” å‘ç°éšè—æ¥å£: ${name}`);
        detectedInterfaces[name] = analyzeInterface(window[name], name);
      }
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  });
  
  // æ£€æµ‹é€šè¿‡ eval æˆ–å…¶ä»–æ–¹å¼æ³¨å…¥çš„æ¥å£
  try {
    const globalVars = Object.keys(window).filter(key => 
      !isNativeProperty(key) && 
      window[key] && 
      typeof window[key] === 'object' &&
      !detectedInterfaces[key]
    );
    
    globalVars.forEach(varName => {
      if (hasJSBridgeMethods(window[varName])) {
        log(`ğŸ¯ å‘ç°å…¨å±€å¯¹è±¡æ¥å£: ${varName}`);
        detectedInterfaces[varName] = analyzeInterface(window[varName], varName);
      }
    });
    
  } catch (error) {
    log(`âš ï¸ æ£€æµ‹éšè—æ¥å£æ—¶å‡ºé”™: ${error.message}`);
  }
}

// æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
function updateStats(interfaces, methods, testable, time) {
  document.getElementById('total-interfaces').textContent = interfaces;
  document.getElementById('total-methods').textContent = methods;
  document.getElementById('testable-methods').textContent = testable;
  document.getElementById('detection-time').textContent = time + 'ms';
}

// æ¸²æŸ“æ¥å£åˆ—è¡¨
function renderInterfaces() {
  const container = document.getElementById('interfaces-container');
  container.innerHTML = '';
  
  if (Object.keys(detectedInterfaces).length === 0) {
    container.innerHTML = `
      <div class="loading">
        <h3>ğŸ˜” æœªå‘ç° JSBridge æ¥å£</h3>
        <p>å¯èƒ½çš„åŸå› ï¼š</p>
        <ul style="text-align: left; max-width: 500px; margin: 0 auto;">
          <li>å½“å‰ç¯å¢ƒä¸æ˜¯ Android WebView</li>
          <li>åº”ç”¨æœªæ³¨å…¥ JavaScript æ¥å£</li>
          <li>æ¥å£ä½¿ç”¨äº†ç‰¹æ®Šçš„å‘½åè§„åˆ™</li>
          <li>æ¥å£è¢«æ··æ·†æˆ–åŠ å¯†</li>
        </ul>
      </div>
    `;
    return;
  }
  
  Object.entries(detectedInterfaces).forEach(([interfaceName, interfaceData]) => {
    const section = createInterfaceSection(interfaceName, interfaceData);
    container.appendChild(section);
  });
}

// åˆ›å»ºæ¥å£åŒºåŸŸ
function createInterfaceSection(interfaceName, interfaceData) {
  const section = document.createElement('div');
  section.className = 'section';
  section.id = `interface-${interfaceName}`;
  
  const header = document.createElement('div');
  header.className = 'section-header';
  header.onclick = () => toggleSection(interfaceName);
  
  const methodCount = Object.keys(interfaceData.methods || {}).length;
  const propCount = Object.keys(interfaceData.properties || {}).length;
  
  header.innerHTML = `
    <span>ğŸ”Œ ${interfaceName} (${methodCount} æ–¹æ³•, ${propCount} å±æ€§)</span>
    <span class="toggle-arrow">â–¼</span>
  `;
  
  const content = document.createElement('div');
  content.className = 'section-content';
  
  // æ¸²æŸ“æ–¹æ³•
  if (methodCount > 0) {
    content.innerHTML += '<h4>ğŸ“‹ å¯ç”¨æ–¹æ³•:</h4>';
    Object.entries(interfaceData.methods).forEach(([methodName, methodInfo]) => {
      content.appendChild(createMethodItem(interfaceName, methodName, methodInfo));
    });
  }
  
  // æ¸²æŸ“å±æ€§
  if (propCount > 0) {
    content.innerHTML += '<h4>ğŸ”§ å±æ€§:</h4>';
    Object.entries(interfaceData.properties).forEach(([propName, propInfo]) => {
      content.appendChild(createPropertyItem(propName, propInfo));
    });
  }
  
  section.appendChild(header);
  section.appendChild(content);
  
  return section;
}

// åˆ›å»ºæ–¹æ³•é¡¹
function createMethodItem(interfaceName, methodName, methodInfo) {
  const item = document.createElement('div');
  item.className = 'method-item';
  
  const params = methodInfo.parameters ? methodInfo.parameters.join(', ') : '';
  const testable = methodInfo.testable ? 'å¯æµ‹è¯•' : 'åŸç”Ÿæ–¹æ³•';
  
  item.innerHTML = `
    <span class="method-name">${methodName}(${params})</span>
    <span class="method-type">${testable}</span>
    ${methodInfo.testable ? `<button class="test-btn" onclick="testMethod('${interfaceName}', '${methodName}')">æµ‹è¯•</button>` : ''}
    <button class="copy-btn" onclick="copyMethodInfo('${interfaceName}', '${methodName}')">å¤åˆ¶</button>
  `;
  
  if (methodInfo.source) {
    const sourceDiv = document.createElement('div');
    sourceDiv.style.cssText = 'margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 3px; font-family: monospace; font-size: 12px; white-space: pre-wrap; overflow-x: auto;';
    sourceDiv.textContent = methodInfo.source;
    item.appendChild(sourceDiv);
  }
  
  return item;
}

// åˆ›å»ºå±æ€§é¡¹
function createPropertyItem(propName, propInfo) {
  const item = document.createElement('div');
  item.className = 'method-item';
  item.style.borderLeftColor = '#e67e22';
  
  item.innerHTML = `
    <span class="method-name">${propName}</span>
    <span class="method-type">${propInfo.type}</span>
    <button class="copy-btn" onclick="copyPropertyInfo('${propName}')">å¤åˆ¶</button>
    <div style="margin-top: 5px; color: #7f8c8d; font-size: 12px;">
      å€¼: ${propInfo.value}
      ${propInfo.error ? `<br>é”™è¯¯: ${propInfo.error}` : ''}
    </div>
  `;
  
  return item;
}

// æµ‹è¯•æ–¹æ³•
function testMethod(interfaceName, methodName) {
  try {
    log(`ğŸ§ª æµ‹è¯•æ–¹æ³•: ${interfaceName}.${methodName}()`);
    
    const result = window[interfaceName][methodName]();
    log(`âœ… æ–¹æ³•è°ƒç”¨æˆåŠŸï¼Œè¿”å›å€¼: ${JSON.stringify(result)}`);
    
  } catch (error) {
    log(`âŒ æ–¹æ³•è°ƒç”¨å¤±è´¥: ${error.message}`);
  }
}

// å¤åˆ¶æ–¹æ³•ä¿¡æ¯
function copyMethodInfo(interfaceName, methodName) {
  const methodInfo = detectedInterfaces[interfaceName].methods[methodName];
  const info = `æ¥å£: ${interfaceName}\næ–¹æ³•: ${methodName}\nå‚æ•°: ${methodInfo.parameters?.join(', ') || 'æ— '}\næºç : ${methodInfo.source || 'ä¸å¯ç”¨'}`;
  
  navigator.clipboard.writeText(info).then(() => {
    log(`ğŸ“‹ å·²å¤åˆ¶æ–¹æ³•ä¿¡æ¯: ${interfaceName}.${methodName}`);
  });
}

// å¤åˆ¶å±æ€§ä¿¡æ¯
function copyPropertyInfo(propName) {
  navigator.clipboard.writeText(`å±æ€§: ${propName}`).then(() => {
    log(`ğŸ“‹ å·²å¤åˆ¶å±æ€§ä¿¡æ¯: ${propName}`);
  });
}

// åˆ‡æ¢åŒºåŸŸæŠ˜å çŠ¶æ€
function toggleSection(interfaceName) {
  const section = document.getElementById(`interface-${interfaceName}`);
  section.classList.toggle('collapsed');
}

// åˆ‡æ¢å…¨éƒ¨æŠ˜å çŠ¶æ€
function toggleAll() {
  allCollapsed = !allCollapsed;
  const sections = document.querySelectorAll('.section');
  sections.forEach(section => {
    if (allCollapsed) {
      section.classList.add('collapsed');
    } else {
      section.classList.remove('collapsed');
    }
  });
}

// è¿‡æ»¤æ¥å£
function filterInterfaces() {
  const searchTerm = document.getElementById('searchBox').value.toLowerCase();
  const sections = document.querySelectorAll('.section');
  
  sections.forEach(section => {
    const text = section.textContent.toLowerCase();
    if (text.includes(searchTerm)) {
      section.style.display = 'block';
      highlightSearchTerm(section, searchTerm);
    } else {
      section.style.display = 'none';
    }
  });
}

// é«˜äº®æœç´¢è¯
function highlightSearchTerm(element, term) {
  if (!term) return;
  
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    null,
    false
  );
  
  const textNodes = [];
  let node;
  while (node = walker.nextNode()) {
    textNodes.push(node);
  }
  
  textNodes.forEach(textNode => {
    const text = textNode.textContent;
    if (text.toLowerCase().includes(term)) {
      const regex = new RegExp(`(${term})`, 'gi');
      const highlightedText = text.replace(regex, '<span class="highlight">$1</span>');
      const wrapper = document.createElement('span');
      wrapper.innerHTML = highlightedText;
      textNode.parentNode.replaceChild(wrapper, textNode);
    }
  });
}

// åˆ·æ–°æ£€æµ‹
function refreshDetection() {
  document.getElementById('interfaces-container').innerHTML = '';
  updateStats(0, 0, 0, 0);
  clearConsole();
  startDetection();
}

// å¯¼å‡ºç»“æœ
function exportResults() {
  const results = {
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    url: window.location.href,
    totalInterfaces: Object.keys(detectedInterfaces).length,
    interfaces: detectedInterfaces,
    logs: consoleLog
  };
  
  const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `jsbridge-analysis-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  log('ğŸ“¤ åˆ†æç»“æœå·²å¯¼å‡º');
}

// é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨å¼€å§‹æ£€æµ‹
window.addEventListener('load', () => {
  log('ğŸš€ JSBridge æ¥å£æ£€æµ‹å·¥å…·å·²å¯åŠ¨');
  setTimeout(startDetection, 1000);
});

// ç›‘å¬é¡µé¢é”™è¯¯
window.addEventListener('error', (event) => {
  log(`âŒ é¡µé¢é”™è¯¯: ${event.error.message}`);
});

</script>

</body>
</html>
